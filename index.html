<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Space Shooter (Mobile ç‰ˆ)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
      touch-action: none; /* é˜²æ­¢è§¦æ‘¸æ»šåŠ¨ */
    }
    #gameCanvas {
      display: block;
      margin: 0 auto;
      background: #000;
      touch-action: none;
    }
    #upgradeOverlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    #upgradeBox {
      background: #222;
      color: #fff;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      font-family: Arial, sans-serif;
      max-width: 90%;
    }
    #upgradeBox button {
      margin: 8px;
      padding: 10px 16px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      border-radius: 6px;
      background: #444;
      color: white;
    }
    #upgradeBox button:hover {
      background: #666;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="400" height="800"></canvas>

  <!-- å‡çº§ç•Œé¢ Overlay -->
  <div id="upgradeOverlay">
    <div id="upgradeBox">
      <h2>é€‰æ‹©æå‡çš„é¡¹ç›®</h2>
      <div id="upgradeOptions"></div>
    </div>
  </div>

  <script>
  (async () => {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // -------------------------------------------------
    // â€”â€” è½½å…¥èµ„æº â€”â€” å›¾åƒ & éŸ³æ•ˆ
    // -------------------------------------------------
    const images = {};
    const sounds = {};

    function loadImage(key, src) {
      return new Promise(resolve => {
        const img = new Image();
        img.src = src;
        img.onload = () => { images[key] = img; resolve(); };
      });
    }

    function loadSound(key, src) {
      return new Promise(resolve => {
        const audio = new Audio(src);
        audio.volume = 0.5;
        sounds[key] = audio;
        // ä¸ä¸€å®šé©¬ä¸Šä¼ å®Œï¼Œä½†å…ˆ store
        resolve();
      });
    }

    // è¯·ç¡®ä¿ä¸‹åˆ—æ–‡ä»¶è·¯å¾„ä¸å®é™…å­˜æ”¾ä½ç½®ä¸€è‡´
    const loadPromises = [
      loadImage('player',   './ufo.png'),
      loadImage('enemy',    './enemy.png'),
      loadImage('background','./background.png'),
      loadImage('laser',    './laser.png'),
      loadImage('fireball','./fireball.png'),
      loadSound('bgm',      './8hp8q-bq1d0.wav'),
      loadSound('shoot',    './xf9c1-23hih.wav'),
      loadSound('explosion','./explosion.wav'),
    ];
    await Promise.all(loadPromises);

    // -------------------------------------------------
    // â€”â€” åŸºç¡€ç±»å®šä¹‰ â€”â€” 
    // -------------------------------------------------
    class Rectangle {
      constructor(x, y, w, h) {
        this.x = x; this.y = y; this.w = w; this.h = h;
      }
      intersects(other) {
        return !(
          other.x > this.x + this.w ||
          other.x + other.w < this.x ||
          other.y > this.y + this.h ||
          other.y + other.h < this.y
        );
      }
    }

    class Enemy {
      constructor(x, y, hp, atk, def) {
        this.rect    = new Rectangle(x, y, 40, 30);
        this.health  = hp;
        this.attack  = atk;
        this.defense = def;
        this.dirX = Math.random() < 0.5 ? 1 : -1;
        this.dirY = Math.random() < 0.5 ? 1 : -1;
      }
    }

    class Bullet {
      constructor(x, y, vx, vy) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy;
      }
      update() { this.x += this.vx; this.y += this.vy; }
      getRect() { return new Rectangle(this.x, this.y, 5, 10); }
    }

    class Fireball {
      constructor(x, y, vx, vy) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy;
      }
      update() { this.x += this.vx; this.y += this.vy; }
      getRect() { return new Rectangle(this.x, this.y, 16, 16); }
    }

    class EnemyBullet {
      constructor(x, y, vx, vy) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy;
      }
      update() { this.x += this.vx; this.y += this.vy; }
      getRect() { return new Rectangle(this.x, this.y, 5, 10); }
    }

    class DamageText {
      constructor(text, x, y) {
        this.text = text; this.x = x; this.y = y; this.life = 60;
      }
    }

    // -------------------------------------------------
    // â€”â€” å…¨å±€å˜é‡ â€”â€” ï¼ˆæ¸¸æˆçŠ¶æ€ï¼‰
    // -------------------------------------------------
    let playerX = canvas.width / 2 - 25;
    let playerY = canvas.height - 30 - 10;
    const PLAYER_WIDTH  = 50;
    const PLAYER_HEIGHT = 30;
    let playerMaxHealth = 200;  // åˆå§‹ç”Ÿå‘½ 200
    let playerHealth    = playerMaxHealth;
    let playerAttack    = 26;   // åˆå§‹æ”»å‡» 26
    let playerDefense   = 10;   // åˆå§‹é˜²å¾¡ 10
    let playerAttackSpeed = 1.0; // å°„é€Ÿï¼ˆæ¯ç§’å‘å°„æ¬¡æ•°ï¼‰
    let lastAutoFireTime = 0;    // è‡ªåŠ¨å‘å°„å­å¼¹çš„è®¡æ—¶
    let lastFireballTime= 0;     // ç«çƒå†·å´è®¡æ—¶
    const BASE_FIREBALL_COOLDOWN = 10000; // 10 ç§’

    // æŠ€èƒ½ç­‰çº§
    let multiShotLevel    = 0;
    let chainAttackLevel  = 0;
    let fireballSkillLevel= 0;
    let diagonalShotLevel = 0;
    let deathChainLevel   = 0;

    // ç»éªŒ & å‡çº§
    let playerLevel = 1;
    let playerXP    = 0;
    let xpToNext    = 50;
    let leveling    = false;
    let pauseStartTime    = 0;
    let pausedRemainingCd = 0;

    // è§¦å±ç§»åŠ¨çŠ¶æ€
    let touchX = null, touchY = null;

    // æ•Œäººã€å­å¼¹ã€ç«çƒã€æ•Œäººå­å¼¹ã€ä¼¤å®³æ–‡å­—
    const enemies      = [];
    const bullets      = [];
    const fireballs    = [];
    const enemyBullets = [];
    const damageTexts  = [];
    const random       = Math.random;

    // -------------------------------------------------
    // â€”â€” è§¦å±ç§»åŠ¨ â€”â€” 
    //    ç”¨æ‰‹æŒ‡æŒ‰ä½ç”»å¸ƒå³å¯æ§åˆ¶ç©å®¶ä½ç½®
    // -------------------------------------------------
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      touchX = (t.clientX - rect.left) * (canvas.width / rect.width);
      touchY = (t.clientY - rect.top)  * (canvas.height / rect.height);
    });
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      touchX = (t.clientX - rect.left) * (canvas.width / rect.width);
      touchY = (t.clientY - rect.top)  * (canvas.height / rect.height);
    });
    canvas.addEventListener('touchend', e => {
      e.preventDefault();
      touchX = touchY = null;
    });

    // -------------------------------------------------
    // â€”â€” æ˜¾ç¤ºå‡çº§ç•Œé¢ â€”â€” HTML Overlay + æŒ‰é’® 
    // -------------------------------------------------
    const upgradeOverlay = document.getElementById('upgradeOverlay');
    const upgradeOptions = document.getElementById('upgradeOptions');

    function showUpgradeDialog() {
      // 1) è®¡ç®—å¹¶å†»ç»“å‰©ä½™å†·å´
      const now = performance.now();
      const fbCd = Math.max(10000, BASE_FIREBALL_COOLDOWN - fireballSkillLevel * 1000);
      pausedRemainingCd = Math.max(0, fbCd - (now - lastFireballTime));
      pauseStartTime = now;

      // 2) å‡†å¤‡é€‰é¡¹
      const opts = [];
      if (playerLevel % 5 === 0) {
        if (multiShotLevel     < 3) opts.push('MULTI_SHOT');
        if (chainAttackLevel   < 3) opts.push('CHAIN_ATTACK');
        if (fireballSkillLevel < 3) opts.push('FIREBALL');
        if (diagonalShotLevel  < 3) opts.push('DIAGONAL_SHOT');
        if (deathChainLevel    < 3) opts.push('DEATH_CHAIN');
      }
      if (opts.length < 3) {
        const base = ['Max Health','Attack','Attack Speed','Defense'];
        base.sort(() => 0.5 - Math.random());
        opts.push(...base.slice(0, 3));
      }
      opts.sort(() => 0.5 - Math.random());

      // æ¸…ç©ºæ—§æŒ‰é’®
      upgradeOptions.innerHTML = '';
      opts.slice(0, 3).forEach(opt => {
        const btn = document.createElement('button');
        btn.textContent = opt;
        btn.onclick = () => {
          switch(opt) {
            case 'Max Health':
              playerMaxHealth += 40; // æ¯æ¬¡ +40
              playerHealth = Math.min(playerHealth + 40, playerMaxHealth);
              break;
            case 'Attack':
              playerAttack += 10;   // è¯¥é¡¹åœ¨æ‰‹æœºç‰ˆæ”¹ä¸ºè‡ªåŠ¨æ”»å‡»ï¼Œä¸éœ€è¦æ‰‹åŠ¨åŠ æ”»å‡»é‡
              break;
            case 'Attack Speed':
              playerAttackSpeed *= 1.2;
              break;
            case 'Defense':
              playerDefense += 5; // æ¯æ¬¡ +10
              break;
            case 'MULTI_SHOT':
              multiShotLevel++;
              break;
            case 'CHAIN_ATTACK':
              chainAttackLevel++;
              break;
            case 'FIREBALL':
              fireballSkillLevel++;
              break;
            case 'DIAGONAL_SHOT':
              diagonalShotLevel++;
              break;
            case 'DEATH_CHAIN':
              deathChainLevel++;
              break;
          }
          // å…³é—­ Overlayï¼Œå¹¶è¡¥å¿å†·å´
          upgradeOverlay.style.display = 'none';
          leveling = false;
          const paused = performance.now() - pauseStartTime;
          lastFireballTime += paused;
          // è§¦æ‘¸æ—¶å¯èƒ½ä¸å†æŒ‰ä¸‹ï¼Œå…³æ‰æ»‘åŠ¨çŠ¶æ€
          touchX = touchY = null;
        };
        upgradeOptions.appendChild(btn);
      });

      // 3) æ˜¾ç¤º Overlay
      upgradeOverlay.style.display = 'flex';
    }

    // -------------------------------------------------
    // â€”â€” æ ¸å¿ƒæ¸¸æˆå¾ªç¯ â€”â€” æ›´æ–° & æ¸²æŸ“ 
    // -------------------------------------------------
    let lastFrameTime = 0;
    function gameLoop(timestamp) {
      const delta = timestamp - lastFrameTime;
      lastFrameTime = timestamp;
      updateGame(delta);
      renderGame();
      requestAnimationFrame(gameLoop);
    }

    function updateGame(delta) {
      if (leveling) return;

      // 1) ç©å®¶è·Ÿéšæ‰‹æŒ‡ç§»åŠ¨
      if (touchX !== null && touchY !== null) {
        // ç©å®¶ä¸­å¿ƒè·Ÿéš touchXã€touchY
        playerX = touchX - PLAYER_WIDTH / 2;
        playerY = touchY - PLAYER_HEIGHT / 2;
        // è¾¹ç•Œé™åˆ¶
        playerX = Math.max(0, Math.min(playerX, canvas.width - PLAYER_WIDTH));
        playerY = Math.max(0, Math.min(playerY, canvas.height - PLAYER_HEIGHT));
      }

      const now = performance.now();

      // 2) è‡ªåŠ¨å°„å‡»å­å¼¹ï¼ˆå¤šé‡ + æ–œå°„ï¼‰
      if (now - lastAutoFireTime >= 1000 / playerAttackSpeed) {
        sounds['shoot']?.cloneNode().play();
        const shots = 1 + multiShotLevel;
        const baseX = playerX + PLAYER_WIDTH / 2 - 2.5;
        const baseY = playerY;
        for (let i = 0; i < shots; i++) {
          bullets.push(new Bullet(baseX, baseY, 0, -10));
          for (let k = 1; k <= diagonalShotLevel; k++) {
            bullets.push(new Bullet(baseX, baseY, -k * 1.0, -10));
            bullets.push(new Bullet(baseX, baseY,  k * 1.0, -10));
          }
        }
        lastAutoFireTime = now;
      }

      // æ›´æ–°å­å¼¹
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].update();
        if (
          bullets[i].y < 0 ||
          bullets[i].x < 0 ||
          bullets[i].x > canvas.width
        ) {
          bullets.splice(i, 1);
        }
      }

      // 3) è‡ªåŠ¨å‘å°„ç«çƒï¼ˆæ— æŒ‰é”®ï¼Œåªè¦å†·å´ç»“æŸå°±å‘ï¼‰
      const fbCd = Math.max(10000, BASE_FIREBALL_COOLDOWN - fireballSkillLevel * 1000);
      if (
        fireballSkillLevel > 0 &&
        now - lastFireballTime >= fbCd
      ) {
        fireballs.push(new Fireball(
          playerX + PLAYER_WIDTH / 2 - 8,
          playerY,
          0, -8
        ));
        lastFireballTime = now;
      }

      // æ›´æ–°ç«çƒ
      for (let i = fireballs.length - 1; i >= 0; i--) {
        fireballs[i].update();
        if (fireballs[i].y < 0) {
          fireballs.splice(i, 1);
        }
      }

      // 4) æ•Œäººç”Ÿæˆ
      if (Math.random() < 1 / 80) {
        enemies.push(new Enemy(
          Math.random() * (canvas.width - 40),
          -30,
          50, 15, 5
        ));
      }

      // 5) æ•Œäººç§»åŠ¨ & æ”»å‡»
      const midY = canvas.height / 2;
      const rng  = 30;
      enemies.forEach(e => {
        if (e.rect.y < midY - rng) {
          e.rect.y += 3;
        } else {
          if (Math.random() < 1 / 30) e.dirX = Math.random() < 0.5 ? 1 : -1;
          if (Math.random() < 1 / 30) e.dirY = Math.random() < 0.5 ? 1 : -1;
          e.rect.x = Math.max(0, Math.min(e.rect.x + e.dirX * 2, canvas.width - e.rect.w));
          e.rect.y = Math.max(midY - rng, Math.min(e.rect.y + e.dirY * 2, midY + rng));
          if (Math.random() < 1 / 150) {
            const sx = e.rect.x + e.rect.w / 2;
            const sy = e.rect.y + e.rect.h;
            const dx = (playerX + PLAYER_WIDTH / 2) - sx;
            const dy = (playerY + PLAYER_HEIGHT / 2) - sy;
            const dist = Math.hypot(dx, dy);
            const spd = 5;
            enemyBullets.push(new EnemyBullet(
              sx, sy, dx / dist * spd, dy / dist * spd
            ));
          }
        }
      });
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        enemyBullets[i].update();
        if (
          enemyBullets[i].y > canvas.height ||
          enemyBullets[i].x < 0 ||
          enemyBullets[i].x > canvas.width
        ) {
          enemyBullets.splice(i, 1);
        }
      }

      // 6) å­å¼¹å‡»ä¸­æ•Œäºº + Chain Attack + Death Chain
      for (let bi = bullets.length - 1; bi >= 0; bi--) {
        const b = bullets[bi];
        let removedBullet = false;
        for (const e of Array.from(enemies)) {
          if (b.getRect().intersects(e.rect)) {
            bullets.splice(bi, 1);
            removedBullet = true;

            // 6.1) ä¼¤å®³ä¸å›è¡€
            const raw = playerAttack;
            const actual = raw * (100 / (100 + e.defense));
            const dmg = Math.floor(actual);
            if (dmg > 0) {
              e.health -= dmg;
              damageTexts.push(new DamageText('-' + dmg, e.rect.x + e.rect.w / 2, e.rect.y));
              const heal = Math.round(actual * 0.1);
              playerHealth = Math.min(playerHealth + heal, playerMaxHealth);
              if (heal > 0) {
                damageTexts.push(new DamageText('+' + heal, playerX + PLAYER_WIDTH / 2, playerY));
              }
            }

            // 6.2) Chain Attack ï¼ˆå•æ¬¡å¼¹å°„ï¼‰
            if (chainAttackLevel > 0 && dmg > 0) {
              const snap = Array.from(enemies);
              const srcX = e.rect.x + e.rect.w / 2;
              const srcY = e.rect.y + e.rect.h / 2;
              let closest = null, minD = Infinity;
              for (const o of snap) {
                if (o !== e) {
                  const dx = (o.rect.x + o.rect.w / 2) - srcX;
                  const dy = (o.rect.y + o.rect.h / 2) - srcY;
                  const dd = Math.hypot(dx, dy);
                  if (dd < minD) { minD = dd; closest = o; }
                }
              }
              if (closest) {
                const rawB = playerAttack * chainAttackLevel;
                const actB = rawB * (100 / (100 + closest.defense));
                const bDmg = Math.floor(actB);
                if (bDmg > 0) {
                  closest.health -= bDmg;
                  damageTexts.push(new DamageText(
                    '*' + bDmg,
                    closest.rect.x + closest.rect.w / 2,
                    closest.rect.y
                  ));
                  if (closest.health <= 0) {
                    enemies.splice(enemies.indexOf(closest), 1);
                    playerXP += 50;
                  }
                }
              }
            }

            // 6.3) Death Chain ï¼ˆæ— é™è¿é”ï¼‰
            if (e.health <= 0) {
              enemies.splice(enemies.indexOf(e), 1);
              playerXP += 50;
              if (deathChainLevel > 0) {
                const snap2 = Array.from(enemies);
                const queue = [{ x: e.rect.x + e.rect.w / 2, y: e.rect.y + e.rect.h / 2 }];
                const radius = 100;
                while (queue.length) {
                  const center = queue.shift();
                  let c2 = null, md2 = Infinity;
                  for (const o2 of snap2) {
                    const dx2 = (o2.rect.x + o2.rect.w / 2) - center.x;
                    const dy2 = (o2.rect.y + o2.rect.h / 2) - center.y;
                    const dd2 = Math.hypot(dx2, dy2);
                    if (dd2 > 0 && dd2 <= radius && dd2 < md2) {
                      md2 = dd2; c2 = o2;
                    }
                  }
                  if (!c2) break;
                  const rawC = playerAttack*0.8* deathChainLevel;
                  const actC = rawC * (100 / (100 + c2.defense));
                  const dD = Math.floor(actC);
                  if (dD > 0) {
                    c2.health -= dD;
                    damageTexts.push(new DamageText(
                      '#' + dD,
                      c2.rect.x + c2.rect.w / 2,
                      c2.rect.y
                    ));
                    if (c2.health <= 0) {
                      enemies.splice(enemies.indexOf(c2), 1);
                      snap2.splice(snap2.indexOf(c2), 1);
                      playerXP += 50;
                      queue.push({
                        x: c2.rect.x + c2.rect.w / 2,
                        y: c2.rect.y + c2.rect.h / 2
                      });
                    }
                  }
                }
              }
            }

            break;  // è·³å‡ºæ•Œäººç¢°æ’æ£€æµ‹
          }
        }
        if (removedBullet) continue;
      }

      // 7) ç«çƒçˆ†ç‚¸èŒƒå›´ä¼¤å®³
      for (let i = fireballs.length - 1; i >= 0; i--) {
        const f = fireballs[i];
        let exploded = false;
        for (const e of Array.from(enemies)) {
          if (f.getRect().intersects(e.rect)) {
            sounds['explosion']?.cloneNode().play();
            fireballs.splice(i, 1);
            exploded = true;
            const radius = 50 + 20 * fireballSkillLevel;
            const epicX = f.x + 8, epicY = f.y + 8;
            const eRaw = playerAttack *3* fireballSkillLevel;
            for (const a of Array.from(enemies)) {
              const dx = (a.rect.x + a.rect.w / 2) - epicX;
              const dy = (a.rect.y + a.rect.h / 2) - epicY;
              if (Math.hypot(dx, dy) <= radius) {
                const aAct = eRaw * (100 / (100 + a.defense));
                const aDmg = Math.floor(aAct);
                if (aDmg > 0) {
                  a.health -= aDmg;
                  damageTexts.push(new DamageText(
                    'ğŸ”¥' + aDmg,
                    a.rect.x + a.rect.w / 2,
                    a.rect.y
                  ));
                  if (a.health <= 0) {
                    enemies.splice(enemies.indexOf(a), 1);
                    playerXP += 50;
                  }
                }
              }
            }
            break;
          }
        }
        if (exploded) continue;
      }

      // 8) æ•Œäººå­å¼¹æ‰“åˆ°ç©å®¶
      const playerRect = new Rectangle(playerX + 10, playerY + 5, 30, 20);
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const eb = enemyBullets[i];
        eb.update();
        if (eb.getRect().intersects(playerRect)) {
          enemyBullets.splice(i, 1);
          const rawD = 15 * (100 / (100 + playerDefense));
          const dInt = Math.floor(rawD);
          if (dInt > 0) {
            playerHealth = Math.max(playerHealth - dInt, 0);
            damageTexts.push(new DamageText(
              '-' + dInt,
              playerX + PLAYER_WIDTH / 2,
              playerY
            ));
            if (playerHealth <= 0) {
              alert('Game Over');
              window.location.reload();
            }
          }
        }
      }

      // 9) æ›´æ–°ä¼¤å®³æ–‡å­—ç”Ÿå‘½
      for (let i = damageTexts.length - 1; i >= 0; i--) {
        const dt = damageTexts[i];
        dt.y -= 1;
        dt.life -= 1;
        if (dt.life <= 0) damageTexts.splice(i, 1);
      }

      // 10) ç»éªŒ & å‡çº§
      if (playerXP >= xpToNext) {
        playerXP -= xpToNext;
        playerLevel++;
        xpToNext = Math.floor(xpToNext * 1.5);
        leveling = true;
        showUpgradeDialog();
      }
    }

    // -------------------------------------------------
    // â€”â€” æ¸²æŸ“å½“å‰å¸§ â€”â€” 
    // -------------------------------------------------
    function renderGame() {
      // 1) èƒŒæ™¯
      ctx.drawImage(images['background'], 0, 0, canvas.width, canvas.height);

      // 2) ç©å®¶
      ctx.drawImage(images['player'], playerX, playerY, PLAYER_WIDTH, PLAYER_HEIGHT);
      // è¡€æ¡
      const barW = PLAYER_WIDTH * playerHealth / playerMaxHealth;
      ctx.fillStyle = '#333';
      ctx.fillRect(playerX, playerY - 8, PLAYER_WIDTH, 5);
      ctx.fillStyle = '#0f0';
      ctx.fillRect(playerX, playerY - 8, barW, 5);
      // å±æ€§æ–‡å­—
      ctx.fillStyle = '#fff';
      ctx.font = '14px Arial';
      ctx.fillText(`HP:${playerHealth.toFixed(0)}/${playerMaxHealth.toFixed(0)}`, 10, 20);
      ctx.fillText(`ATK:${playerAttack.toFixed(0)} DEF:${playerDefense.toFixed(0)} SPD:${playerAttackSpeed.toFixed(1)}`, 10, 40);
      ctx.fillText(`LV:${playerLevel} XP:${playerXP}/${xpToNext}`, 10, 60);

      // Fireball å†·å´æ˜¾ç¤º
      if (fireballSkillLevel > 0) {
        let cdText;
        if (leveling) {
          const sec = pausedRemainingCd / 1000;
          cdText = pausedRemainingCd <= 0
            ? 'Fireball CD: READY'
            : `Fireball CD: ${sec.toFixed(1)}s`;
        } else {
          const now = performance.now();
          const fbCd = Math.max(10000, BASE_FIREBALL_COOLDOWN - fireballSkillLevel * 1000);
          const since = now - lastFireballTime;
          cdText = since >= fbCd
            ? 'Fireball CD: READY'
            : `Fireball CD: ${( (fbCd - since) / 1000 ).toFixed(1)}s`;
        }
        ctx.fillText(cdText, 10, 80);
      }

      // 3) å­å¼¹
      bullets.forEach(b => {
        ctx.drawImage(images['laser'], b.x, b.y, 5, 10);
      });
      // 4) ç«çƒ
      fireballs.forEach(f => {
        ctx.drawImage(images['fireball'], f.x, f.y, 16, 16);
      });
      // 5) æ•Œäºº
      enemies.forEach(e => {
        ctx.drawImage(images['enemy'], e.rect.x, e.rect.y, e.rect.w, e.rect.h);
        const ebw = e.rect.w * e.health / 50;
        ctx.fillStyle = '#333';
        ctx.fillRect(e.rect.x, e.rect.y - 6, e.rect.w, 5);
        ctx.fillStyle = '#f00';
        ctx.fillRect(e.rect.x, e.rect.y - 6, ebw, 5);
      });
      // 6) æ•Œäººå­å¼¹
      enemyBullets.forEach(eb => {
        ctx.drawImage(images['laser'], eb.x, eb.y, 5, 10);
      });
      // 7) ä¼¤å®³æ–‡å­—
      ctx.fillStyle = '#fff';
      ctx.font = '16px Arial';
      damageTexts.forEach(dt => {
        ctx.fillText(dt.text, dt.x, dt.y);
      });
    }

    // -------------------------------------------------
    // â€”â€” æ’­æ”¾éŸ³æ•ˆ â€”â€” 
    // -------------------------------------------------
    function playSound(key) {
      if (!sounds[key]) return;
      const audio = sounds[key].cloneNode();
      audio.play();
    }

    // -------------------------------------------------
  // â€”â€” å¯åŠ¨æ¸¸æˆ â€”â€” 
// æ³¨å†Œä¸€ä¸ªä¸€æ¬¡æ€§çš„è§¦æ‘¸/ç‚¹å‡»äº‹ä»¶ï¼Œè®©ç”¨æˆ·é¦–æ¬¡äº¤äº’æ—¶å†æ’­æ”¾èƒŒæ™¯éŸ³ä¹
let bgmStarted = false;
function startBgmOnUserGesture() {
  if (!bgmStarted && sounds['bgm']) {
    sounds['bgm'].loop = true;
    sounds['bgm'].play().catch(_=>{}); // æŸäº›æµè§ˆå™¨å¯èƒ½æŠ›â€œç”¨æˆ·æœªäº¤äº’â€å¼‚å¸¸ï¼Œcatch æ‰
    bgmStarted = true;
  }
  // æ³¨å†Œæ—¶åŠ ä¸Š { once: true }ï¼Œæ‰€ä»¥äº‹ä»¶ä¼šè‡ªåŠ¨ç§»é™¤ï¼Œä¸ç”¨æ‰‹åŠ¨ remove
}

window.addEventListener('touchstart', startBgmOnUserGesture, { once: true });
window.addEventListener('click',     startBgmOnUserGesture, { once: true });

// ç«‹å³å¼€å§‹ä¸»å¾ªç¯
requestAnimationFrame(gameLoop);

  })();
  </script>
</body>
</html>
